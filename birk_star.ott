embed
{{ tex-preamble
\synctex=1
\usepackage{fontspec}
\usepackage{fontawesome5}
\usepackage{cancel}
}}

% term variables, represented by x in the grammar, are to be represented using
% natural numbers in Coq
metavar termvar, x, y, v, w ::= {{ coq nat }} {{ coq-equality }}

indexvar index, k, z, s, A, B, P, a, b, r ::= {{ coq nat }}

% BEGIN: grammar definitions
grammar
 
terminals :: 'terminals_' ::=
  | \                   ::   :: lambda     {{ tex \lambda }}
  | -->                 ::   :: reduce     {{ tex \Longrightarrow }}
  | ->                  ::   :: arrow      {{ tex \rightarrow }}
  | |-                  ::   :: turnstile  {{ tex \vdash }}
  | in                  ::   :: in         {{ tex \in }}
  | lock                ::   :: lock       {{ tex \text{\faLock} }}
  | empty               ::   :: empty      {{ tex \cdot }}
  | ctx                 ::   :: ctx        {{ tex \textbf{ ctx} }}
  | pi                  ::   :: pi         {{ tex \Pi }}
  | box                 ::   :: box        {{ tex \square }}
  | nat                 ::   :: nat        {{ tex \mathbb{N} }}
  | beta                ::   :: beta       {{ tex \beta }}
  | gamma               ::   :: gamma      {{ tex \gamma }}
  | eq                  ::   :: eq         {{ tex = }}

i :: 'nat_' ::=
{{ coq (nat) }}
  | 0                   ::   :: zero {{ coq 0 }}
  | s i                 ::   :: succ {{ tex [[i]] + 1 }}
                                     {{ coq (S [[i]]) }}

term, t :: 't_' ::=
  % constructions that are properly 'term'
  | x               ::  :: Var    
    {{ com variables }}
  | zero            ::  :: Zero   
    {{ com natural number 0 }}
  | succ t          ::  :: Succ   
    {{ com successor of natural number t }}
  | rec x v tP t tz ts  ::  :: Rec
    (+ bind x in tP +) (+ bind x union v in ts +)
    {{ com (dependent) recursor for natural numbers }}
    {{ tex \mathbf{rec}([[x]].[[tP]], [[t]], [[tz]], [[x]].[[v]].[[ts]]) }}
  | \ x : tA , t    ::  :: Lam    
    (+ bind x in t +)
    {{ com lambda abstraction }}
  | t t'            ::  :: App    
    {{ com function application }}
  | quote t         ::  :: Quote  
    {{ com quote term $[[t]]$ as code }}
    {{ tex [ [[t]] ]_{\text{\faLock} } }}
  | splice t        ::  :: Splice 
    {{ com splice code t as term }}
    {{ tex [ [[t]] ]_{\text{\faUnlock} } }}
  | refl t          ::  :: Refl
    {{ com constructor for t = t }}
    {{ tex \mathbf{refl}_{[[t]]} }}
  | J x y w v tP ta tb t tr ::  :: PathI
    (+ bind x union y union w in tP +) (+ bind v in tr +)
    {{ com path induction for equality }}
    {{ tex \mathbf{J}([[x]].[[y]].[[w]].[[tP]], [[ta]], [[tb]], [[t]], 
           [[v]].[[tr]]) }}
  % type constructions
  | nat             ::  :: Nat
    {{ com natural number type }}
  | pi x : tA , tB  ::  :: Fun
    (+ bind x in tB +)
    {{ com dependent function type }}
  | box t           ::  :: Box
    {{ com terms of $[[t]]$ as code }}
  | t eq tA t'      ::  :: Eq
    {{ com propositional equality }}
    {{ tex [[t]] =_{[[tA]]} [[t']] }}
  | univ i          ::  :: Univ
    {{ com type universe }}
    {{ tex \mathcal{U}_{[[i]]} }}
  % sugaring and substitution
  | ( t )          :: S:: Par
    {{ coq [[t]] }}
  | t [ x1 := t1 , .. , xk := tk ]   :: M:: Sub
    {{ coq (subst_term [[x1 t1 .. xk tk]] [[t]])}}

context, C {{ tex \Gamma }} :: 'C_' ::=
{{ coq (list (option (termvar*term))) }}
  | empty        ::  :: Emp
    {{ coq C_nil }}
  | C , x : t    ::  :: ConsVar
    (+ bind x in C +) % prevent the x from being substituted
    {{ coq (cons (C_var ([[x]], [[t]])) [[C]]) }}
  | C , lock     ::  :: ConsLock
    {{ coq (cons C_lock [[C]]) }}
  | unlock C     :: M:: Unlock
    {{ coq (C_unlock [[C]]) }} 
    {{ tex {[[C]]}^{ \text{\faUnlock} } }}

reduction_strat, R :: 'R_' ::=
  | beta     ::  :: Beta
  | gamma    ::  :: Gamma

value, e :: 'val_' ::=
  | quote p        ::  :: Quote  {{ tex [ [[p]] ]_{\text{\faLock} } }}
  | \ x : t , m    ::  :: Lam    (+ bind x in m +)

normal_beta, m :: 'b_norm_' ::=
  | u              ::  :: Neutral {{ com a neutral term is beta normal }}
  | quote p        ::  :: Quote   {{ tex [ [[p]] ]_{\text{\faLock} } }}
  | \ x : t , m    ::  :: Lam     (+ bind x in m +)

normal_gamma, p :: 'g_norm_' ::=
  | x              ::  :: Var
  | \ x : t , p    ::  :: Lam    (+ bind x in p +) 
  | p1 p2          ::  :: App
  | quote p        ::  :: Quote  {{ tex [ [[p]] ]_{\text{\faLock} } }}
  | splice u       ::  :: Splice {{ tex [ [[u]] ]_{\text{\faUnlock} } }}

neutral, u :: 'u_norm_' ::=
  | x              ::  :: Var
  | u m            ::  :: App
  | splice u       ::  :: Splice {{ tex [ [[u]] ]_{\text{\faUnlock} } }}

formula :: 'formula_' ::=
  | judgement   ::  :: judgement
  | x : tA in C ::  :: in {{ coq (C_in [[x]] [[tA]] [[C]]) }}
                          {{ tex [[C]] = \Gamma_1, [[x]] : [[tA]], \Gamma_2 
                             \text{ and } \text{\faLock} \not\in \Gamma_2 }}
  | x nin C     ::  :: nin {{ tex [[x]] \not\in [[C]] }}
                           {{ coq  (C_var_nin [[x]] [[C]]) }}

% BEGIN: substitutions
substitutions
  multiple t x :: subst%_term
% END: substitutions                

embed
{{ coq
Notation C_var := Some.
Notation C_lock := None.
Notation C_nil := (@nil (option (termvar*term))).
Definition C_in (x : termvar) (T : term) (C : context) :=
  exists C1, exists C2,
    (C = List.app C1 (List.cons (Some (x,T)) C2)) /\
    (~ exists T', In (Some (x, T')) C1) /\
    (~ In C_lock C1).
Definition C_var_nin (x : termvar) (C : context) :=
  forall T, ~ (In (Some (x,T)) C).
Definition is_var {A : Type} (o : option A) :=
  match o with
  | C_lock   => false
  | C_var _  => true
  end.
Definition C_unlock (C : context) := filter is_var C.
Fixpoint subst_context (sub:list (termvar*term)) (C : context) : context :=
  match C with
  | nil => nil
  | cons C_lock C => cons C_lock (subst_context sub C)
  | cons (C_var (x, T)) C => cons (C_var (x, subst_term sub T)) (subst_context sub C)
  end.
}}
% END: grammar definitions

% BEGIN: judgement definitions - typing, reduction etc.
defns
Infer :: '' ::=

defn C ctx ::  ::ctx_form::''
{{ com $[[C]]$ is a well-formed context }} by

  --------- :: ctx_emp
  empty ctx

  % we can prove that C |- tA : univ i implies C ctx, so we don't need to
  % explicitly require this.
  x nin C
  C |- tA : univ i
  ---------------- :: ctx_var
  C, x : tA ctx

  C ctx
  ----------- :: ctx_lock
  C, lock ctx

defn C |- t1 : t2 ::  ::type_of_term::''
{{ com $[[t1]]$ has type $[[t2]]$ under context $[[C]]$ }} by

  C ctx
  ------------------------ :: univ_form
  C |- univ i : univ s i

  C ctx
  ----------------- :: nat_form
  C |- nat : univ i

  C |- tA : univ i
  C , x : tA |- tB : univ i
  ---------------------------- :: pi_form
  C |- pi x : tA, tB : univ i

  C, lock |- tA : univ i
  --------------------- :: box_form
  C |- box tA : univ i

  C |- tA : univ i
  ------------------- :: univ_cumul
  C |- tA : univ s i

  C ctx
  --------------- :: nat_zero
  C |- zero : nat

  C |- t : nat
  ----------------- :: nat_succ
  C |- succ t : nat

  C, x : nat |- tP : univ i
  C |- t : nat
  C |- tz : tP [x := zero]
  C, x : nat, v : tP |- ts : tP[x := succ x]
  ------------------------------------------- :: nat_elim
  C |- rec x v tP t tz ts : tP[x := t]

  C ctx
  x : tA in C
  ----------- :: term_var
  C |- x : tA

  % C |- tA : univ i
  C, x : tA |- t : tB
  ------------------------------- :: pi_intro
  C |- \x : tA, t : pi x : tA, tB

  % C, x : tA |- tB : univ i 
  C |- t1 : pi x : tA, tB
  C |- t2 : tA
  ------------------------ :: pi_elim
  C |- t1 t2 : tB[x := t2]

  C, lock |- t1 : tA
  ---------------------- :: box_intro
  C |- quote t1 : box tA

  % we need to explicitly have C |- tA : univ i because otherwise we need to
  % have (unlock C ctx) implies (C ctx) when showing that any typing judgement 
  % C |- t : tA implies (C ctx). This is simply not true: counterexample:
  % C = x : univ i, lock, y : (pi z : x, x) is not a well-formed context, but it
  % is when unlocked. 
  C |- tA : univ i
  unlock C |- t : box tA
  ----------------------- :: box_elim
  C |- splice t : tA

  C |- tA : univ i
  C |- t1 : tA
  C |- t2 : tA
  ------------------------- :: eq_form
  C |- t1 eq tA t2 : univ i

  C |- tA : univ i
  C |- t : tA
  ------------------------ :: eq_intro
  C |- refl t : t eq tA t

  C, x : tA, y : tA, w : x eq tA y |- tP : univ i
  C |- ta : tA
  C |- tb : tA
  C |- t : ta eq tA tb
  C, v : tA |- tr : tP[x := v, y := v, w := refl v]
  ----------------------------------------------------------- :: eq_elim
  C |- J x y w v tP ta tb t tr : tP[x := ta, y := tb, w := t]

defn t1 --> R t2 ::  ::reduce::''
{{ com $[[t1]]$ $[[R]]$-reduces to $[[t2]]$ }}
{{ tex [[t1]] \Longrightarrow_{[[R]]} [[t2]] }} by

  ------------------------------------- :: pi_redex
  (\ x : tA, t1) t2 --> beta t1[x := t2]

  -------------------------- :: box_redex
  splice (quote t1) --> R t1

  --------------------------------- :: nat_redex_zero
  rec x v tP zero tz ts --> beta tz

  ------------------------------------------------------------------------- :: nat_redex_succ
  rec x v tP (succ tk) tz ts --> beta ts[x := tk, v := rec x v tP tk tz ts]

  --------------------------------------------------------- :: eq_redex
  J x y w v tP ta ta (refl ta) tr --> beta tr[v := ta]

  t --> R t'
  ------------------------------- :: lam_cong
  \ x : tA, t --> R \ x : tA, t'

  t1 --> R t1'
  ------------------ :: app_cong_L
  t1 t2 --> R t1' t2

  t2 --> R t2'
  ------------------ :: app_cong_R
  t1 t2 --> R t1 t2'

  t --> gamma t'
  ----------------------- :: quote_cong
  quote t --> R quote t'

  t --> beta t'
  -------------------------- :: splice_cong
  splice t --> R splice t'

  t --> R t'
  ------------------ :: succ_cong
  succ t --> R succ t'

  tP --> R tP'
  -------------------------------------------- :: rec_cong_1
  rec x v tP t tz ts --> R rec x v tP' t tz ts

  t --> R t'
  -------------------------------------------- :: rec_cong_2
  rec x v tP t tz ts --> R rec x v tP t' tz ts

  tz --> R tz'
  -------------------------------------------- :: rec_cong_3
  rec x v tP t tz ts --> R rec x v tP t tz' ts

  ts --> R ts'
  -------------------------------------------- :: rec_cong_4
  rec x v tP t tz ts --> R rec x v tP t tz ts'

  ta --> R ta'
  ------------------------------- :: eq_cong_1
  ta eq tA tb --> R ta' eq tA tb

  tA --> R tA'
  ------------------------------- :: eq_cong_2
  ta eq tA tb --> R ta eq tA' tb

  tb --> R tb'
  ------------------------------- :: eq_cong_3
  ta eq tA tb --> R ta eq tA tb'

  ta --> R ta'
  ---------------------- :: refl_cong
  refl ta --> R refl ta'

  tP --> R tP'
  -------------------------------------- :: J_cong_1
  J x y w v tP ta tb t tr --> R J x y w v tP' ta tb t tr

  ta --> R ta'
  -------------------------------------- :: J_cong_2
  J x y w v tP ta tb t tr --> R J x y w v tP ta' tb t tr

  tb --> R tb'
  -------------------------------------- :: J_cong_3
  J x y w v tP ta tb t tr --> R J x y w v tP ta tb' t tr

  t --> R t'
  -------------------------------------- :: J_cong_4
  J x y w v tP ta tb t tr --> R J x y w v tP ta tb t' tr

  tr --> R tr'
  -------------------------------------- :: J_cong_5
  J x y w v tP ta tb t tr --> R J x y w v tP ta tb t tr'
% END: judgement definitions