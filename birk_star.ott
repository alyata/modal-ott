embed
{{ tex-preamble
\synctex=1
\usepackage{fontspec}
\usepackage{fontawesome5}
\usepackage{cancel}
}}

% term variables, represented by x in the grammar, are to be represented using
% natural numbers in Coq
metavar termvar, x, y ::= {{ coq nat }} {{ coq-equality }}

indexvar index, k, z, s ::= {{ coq nat }}

% BEGIN: grammar definitions
grammar
 
terminals :: 'terminals_' ::=
  | \                   ::   :: lambda     {{ tex \lambda }}
  | -->                 ::   :: reduce     {{ tex \Longrightarrow }}
  | ->                  ::   :: arrow      {{ tex \rightarrow }}
  | |-                  ::   :: turnstile  {{ tex \vdash }}
  | in                  ::   :: in         {{ tex \in }}
  | lock                ::   :: lock       {{ tex \text{\faLock} }}
  | empty               ::   :: empty      {{ tex \cdot }}
  | ctx                 ::   :: ctx        {{ tex \textbf{ ctx} }}
  | pi                  ::   :: pi         {{ tex \Pi }}
  | box                 ::   :: box        {{ tex \square }}
  | nat                 ::   :: nat        {{ tex \mathbb{N} }}
  | beta                ::   :: beta       {{ tex \beta }}
  | gamma               ::   :: gamma      {{ tex \gamma }}

i :: 'nat_' ::=
{{ coq (nat) }}
  | 0                   ::   :: zero {{ coq 0 }}
  | s i                 ::   :: succ {{ tex [[i]] + 1 }}
                                     {{ coq (S [[i]]) }}

term, t :: 't_' ::=
  % constructions that are properly 'term'
  | x              ::  :: Var    {{ com variables }}
  | zero           ::  :: Zero   {{ com natural number 0 }}
  | succ t         ::  :: Succ   {{ com successor of natural number t }}
  | rec t tk tz ts ::  :: Rec    {{ com (dependent) recursor for natural 
                                    numbers }}
  | \ x : t , t'   ::  :: Lam    (+ bind x in t' +) 
                                 {{ com lambda abstraction}}
  | t t'           ::  :: App    {{ com function application }}
  | quote t        ::  :: Quote  {{ com quote term $[[t]]$ as code }}
                                 {{ tex [ [[t]] ]_{\text{\faLock} } }}
  | splice t       ::  :: Splice {{ com splice code t as term }}
                                 {{ tex [ [[t]] ]_{\text{\faUnlock} } }}
  % type constructions
  | nat            ::  :: Nat    {{ com natural number type }}
  | pi x : t , t'  ::  :: Fun    (+ bind x in t' +)
                                 {{ com dependent function type }}
  | box t          ::  :: Box    {{ com terms of $[[t]]$ as code }}
  | univ i         ::  :: Univ   {{ com type universe }}
                                 {{ tex \mathcal{U}_{[[i]]} }}
  % sugaring and substitution
  | ( t )          :: S:: Par    {{ coq [[t]] }}
  | t1 [ t2 / x ]  :: M:: Sub    {{ coq (subst_term_in_term [[t2]] [[x]] [[t1]])}}

context, C {{ tex \Gamma }} :: 'C_' ::=
{{ coq (list (option (termvar*term))) }}
  | empty        ::  :: Emp      {{ coq C_nil }}
  | C , x : t    ::  :: ConsVar  {{ coq (cons (C_var ([[x]], [[t]])) [[C]]) }}
  | C , lock     ::  :: ConsLock {{ coq (cons C_lock [[C]]) }}
  | unlock C     :: M:: Unlock   {{ coq (C_unlock [[C]]) }} 
                                 {{ tex {[[C]]}^{ \text{\faUnlock} } }}

reduction_strat, R :: 'R_' ::=
  | beta     ::  :: Beta
  | gamma    ::  :: Gamma

value, e :: 'val_' ::=
  | quote p        ::  :: Quote  {{ tex [ [[p]] ]_{\text{\faLock} } }}
  | \ x : t , m    ::  :: Lam    (+ bind x in m +)

normal_beta, m :: 'b_norm_' ::=
  | u              ::  :: Neutral {{ com a neutral term is beta normal }}
  | quote p        ::  :: Quote   {{ tex [ [[p]] ]_{\text{\faLock} } }}
  | \ x : t , m    ::  :: Lam     (+ bind x in m +)

normal_gamma, p :: 'g_norm_' ::=
  | x              ::  :: Var
  | \ x : t , p    ::  :: Lam    (+ bind x in p +) 
  | p1 p2          ::  :: App
  | quote p        ::  :: Quote  {{ tex [ [[p]] ]_{\text{\faLock} } }}
  | splice u       ::  :: Splice {{ tex [ [[u]] ]_{\text{\faUnlock} } }}

neutral, u :: 'u_norm_' ::=
  | x              ::  :: Var
  | u m            ::  :: App
  | splice u       ::  :: Splice {{ tex [ [[u]] ]_{\text{\faUnlock} } }}

formula :: 'formula_' ::=
  | judgement  ::  :: judgement
  | x : t in C ::  :: in {{ coq (C_in [[x]] [[t]] [[C]]) }}
                         {{ tex \Gamma = \Gamma_1, [[x]] : [[t]], \Gamma_2 
                            \text{ and } \text{\faLock} \not\in \Gamma_2 }}

embed
{{ coq
Notation C_var := Some.
Notation C_lock := None.
Notation C_nil := (@nil (option (termvar*term))).
Definition C_in (x : termvar) (T : term) (C : context) :=
  exists C1, exists C2,
    (C = List.app C1 (List.cons (Some (x,T)) C2)) /\
    (~ exists T', In (Some (x, T')) C1) /\
    (~ In C_lock C1).
Definition is_var {A : Type} (o : option A) :=
  match o with
  | C_lock   => false
  | C_var _  => true
  end.
Definition C_unlock (C : context) := filter is_var C.
}}
% END: grammar definitions

% BEGIN: substitutions
substitutions
  single t x :: subst_term_in%_term

% END: substitutions

% BEGIN: judgement definitions - typing, reduction etc.
defns
Infer :: '' ::=

defn C ctx ::  ::ctx_form::''
{{ com $[[C]]$ is a well-formed context }} by

  --------- :: ctx_emp
  empty ctx

  % don't need C ctx as C |- t : univ i implicitly carries the fact that C is 
  % well-formed
  C |- t : univ i
  --------------- :: ctx_var
  C, x:t ctx

  C ctx
  ----------- :: ctx_lock
  C, lock ctx

defn C |- t1 : t2 ::  ::type_of_term::''
{{ com $[[t1]]$ has type $[[t2]]$ under context $[[C]]$ }} by

  C ctx
  ----------------------- :: univ_form
  C |- univ i : univ s i

  C ctx
  ----------------- :: nat_form
  C |- nat : univ i

  C |- t : univ i
  C , x : t |- t' : univ i
  --------------------------- :: pi_form
  C |- pi x : t, t' : univ i

  C, lock |- t : univ i
  --------------------- :: box_form
  C |- box t : univ i

  C |- t : univ i
  ------------------ :: univ_cumul
  C |- t : univ s i

  C ctx
  --------------- :: nat_zero
  C |- zero : nat

  C |- t : nat
  ----------------- :: nat_succ
  C |- succ t : nat

  C, x : nat |- t : univ i
  C |- tk : nat
  C |- tz : t [zero / x]
  C, x : nat, y : t |- ts : t [succ x / x]
  ---------------------------------------- :: nat_elim
  C |- rec t tk tz ts : t[t1 / x]

  C ctx
  x : t in C
  ---------- :: term_var
  C |- x : t

  C |- t : univ i
  C, x : t |- t1 : t'
  ------------------------------ :: pi_intro
  C |- \x : t, t1 : pi x : t, t'

  C, x : t |- t' : univ i 
  C |- t2 : pi x : t, t'
  C |- t1 : t
  ----------------------- :: pi_elim
  C |- t2 t1 : t'

  C, lock |- t1 : t
  --------------------- :: box_intro
  C |- quote t1 : box t

  C |- t : univ i
  unlock C |- t1 : box t
  ---------------------- :: box_elim
  C |- splice t1 : t

defn t1 --> R t2 ::  ::reduce::''
{{ com $[[t1]]$ $[[R]]$-reduces to $[[t2]]$ }}
{{ tex [[t1]] \Longrightarrow_{[[R]]} [[t2]] }} by

  ------------------------------ :: pi_redex
  (\ x : t, t1) t2 --> beta t1[t2/x]

  t1 --> R t2
  ---------------------- :: lam_cong
  \ x : t, t1 --> R \ x : t, t2

  t1 --> R t2
  ------------------ :: app_cong_L
  t1 t3 --> R t2 t3

  t1 --> R t2
  ------------------ :: app_cong_R
  t3 t1 --> R t3 t2

  --------------------- :: box_redex
  splice (quote t1) --> R t1

  t1 --> gamma t2
  ----------------------- :: quote_cong
  quote t1 --> R quote t2

  t1 --> beta t2
  ---------------------- :: splice_cong
  splice t1 --> R splice t2
% defn t gamma_normal
% END: judgement definitions